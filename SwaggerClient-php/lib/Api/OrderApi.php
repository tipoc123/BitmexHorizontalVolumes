<?php
/**
 * OrderApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * BitMEX API
 *
 * ## REST API for the BitMEX Trading Platform  [Changelog](/app/apiChangelog)    #### Getting Started   ##### Fetching Data  All REST endpoints are documented below. You can try out any query right from this interface.  Most table queries accept `count`, `start`, and `reverse` params. Set `reverse=true` to get rows newest-first.  Additional documentation regarding filters, timestamps, and authentication is available in [the main API documentation](https://www.bitmex.com/app/restAPI).  *All* table data is available via the [Websocket](/app/wsAPI). We highly recommend using the socket if you want to have the quickest possible data without being subject to ratelimits.  ##### Return Types  By default, all data is returned as JSON. Send `?_format=csv` to get CSV data or `?_format=xml` to get XML data.  ##### Trade Data Queries  *This is only a small subset of what is available, to get you started.*  Fill in the parameters and click the `Try it out!` button to try any of these queries.  * [Pricing Data](#!/Quote/Quote_get)  * [Trade Data](#!/Trade/Trade_get)  * [OrderBook Data](#!/OrderBook/OrderBook_getL2)  * [Settlement Data](#!/Settlement/Settlement_get)  * [Exchange Statistics](#!/Stats/Stats_history)  Every function of the BitMEX.com platform is exposed here and documented. Many more functions are available.  -  ## All API Endpoints  Click to expand a section.
 *
 * OpenAPI spec version: 1.2.0
 * Contact: support@bitmex.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use \Swagger\Client\Configuration;
use \Swagger\Client\ApiClient;
use \Swagger\Client\ApiException;
use \Swagger\Client\ObjectSerializer;

/**
 * OrderApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class OrderApi
{

    /**
     * API Client
     *
     * @var \Swagger\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \Swagger\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\Swagger\Client\ApiClient $apiClient = null)
    {
        if ($apiClient == null) {
            $apiClient = new ApiClient();
            $apiClient->getConfig()->setHost('https://localhost/api/v1');
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \Swagger\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \Swagger\Client\ApiClient $apiClient set the API client
     *
     * @return OrderApi
     */
    public function setApiClient(\Swagger\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation orderAmend
     *
     * Amend the quantity or price of an open order.
     *
     * @param string $order_id Order ID (optional)
     * @param string $orig_cl_ord_id Client Order ID. See POST /order. (optional)
     * @param string $cl_ord_id Optional new Client Order ID, requires &#x60;origClOrdID&#x60;. (optional)
     * @param double $simple_order_qty Optional order quantity in units of the underlying instrument (i.e. Bitcoin). (optional)
     * @param float $order_qty Optional order quantity in units of the instrument (i.e. contracts). (optional)
     * @param double $simple_leaves_qty Optional leaves quantity in units of the underlying instrument (i.e. Bitcoin). Useful for amending partially filled orders. (optional)
     * @param float $leaves_qty Optional leaves quantity in units of the instrument (i.e. contracts). Useful for amending partially filled orders. (optional)
     * @param double $price Optional limit price for &#39;Limit&#39;, &#39;StopLimit&#39;, and &#39;LimitIfTouched&#39; orders. (optional)
     * @param double $stop_px Optional trigger price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. (optional)
     * @param double $peg_offset_value Optional trailing offset from the current price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for &#39;Pegged&#39; orders. (optional)
     * @param string $text Optional amend annotation. e.g. &#39;Adjust skew&#39;. (optional)
     * @return \Swagger\Client\Model\Order
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderAmend($order_id = null, $orig_cl_ord_id = null, $cl_ord_id = null, $simple_order_qty = null, $order_qty = null, $simple_leaves_qty = null, $leaves_qty = null, $price = null, $stop_px = null, $peg_offset_value = null, $text = null)
    {
        list($response) = $this->orderAmendWithHttpInfo($order_id, $orig_cl_ord_id, $cl_ord_id, $simple_order_qty, $order_qty, $simple_leaves_qty, $leaves_qty, $price, $stop_px, $peg_offset_value, $text);
        return $response;
    }

    /**
     * Operation orderAmendWithHttpInfo
     *
     * Amend the quantity or price of an open order.
     *
     * @param string $order_id Order ID (optional)
     * @param string $orig_cl_ord_id Client Order ID. See POST /order. (optional)
     * @param string $cl_ord_id Optional new Client Order ID, requires &#x60;origClOrdID&#x60;. (optional)
     * @param double $simple_order_qty Optional order quantity in units of the underlying instrument (i.e. Bitcoin). (optional)
     * @param float $order_qty Optional order quantity in units of the instrument (i.e. contracts). (optional)
     * @param double $simple_leaves_qty Optional leaves quantity in units of the underlying instrument (i.e. Bitcoin). Useful for amending partially filled orders. (optional)
     * @param float $leaves_qty Optional leaves quantity in units of the instrument (i.e. contracts). Useful for amending partially filled orders. (optional)
     * @param double $price Optional limit price for &#39;Limit&#39;, &#39;StopLimit&#39;, and &#39;LimitIfTouched&#39; orders. (optional)
     * @param double $stop_px Optional trigger price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. (optional)
     * @param double $peg_offset_value Optional trailing offset from the current price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for &#39;Pegged&#39; orders. (optional)
     * @param string $text Optional amend annotation. e.g. &#39;Adjust skew&#39;. (optional)
     * @return Array of \Swagger\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderAmendWithHttpInfo($order_id = null, $orig_cl_ord_id = null, $cl_ord_id = null, $simple_order_qty = null, $order_qty = null, $simple_leaves_qty = null, $leaves_qty = null, $price = null, $stop_px = null, $peg_offset_value = null, $text = null)
    {
        // parse inputs
        $resourcePath = "/order";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($order_id !== null) {
            $formParams['orderID'] = $this->apiClient->getSerializer()->toFormValue($order_id);
        }
        // form params
        if ($orig_cl_ord_id !== null) {
            $formParams['origClOrdID'] = $this->apiClient->getSerializer()->toFormValue($orig_cl_ord_id);
        }
        // form params
        if ($cl_ord_id !== null) {
            $formParams['clOrdID'] = $this->apiClient->getSerializer()->toFormValue($cl_ord_id);
        }
        // form params
        if ($simple_order_qty !== null) {
            $formParams['simpleOrderQty'] = $this->apiClient->getSerializer()->toFormValue($simple_order_qty);
        }
        // form params
        if ($order_qty !== null) {
            $formParams['orderQty'] = $this->apiClient->getSerializer()->toFormValue($order_qty);
        }
        // form params
        if ($simple_leaves_qty !== null) {
            $formParams['simpleLeavesQty'] = $this->apiClient->getSerializer()->toFormValue($simple_leaves_qty);
        }
        // form params
        if ($leaves_qty !== null) {
            $formParams['leavesQty'] = $this->apiClient->getSerializer()->toFormValue($leaves_qty);
        }
        // form params
        if ($price !== null) {
            $formParams['price'] = $this->apiClient->getSerializer()->toFormValue($price);
        }
        // form params
        if ($stop_px !== null) {
            $formParams['stopPx'] = $this->apiClient->getSerializer()->toFormValue($stop_px);
        }
        // form params
        if ($peg_offset_value !== null) {
            $formParams['pegOffsetValue'] = $this->apiClient->getSerializer()->toFormValue($peg_offset_value);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = $this->apiClient->getSerializer()->toFormValue($text);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order',
                '/order'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderAmendBulk
     *
     * Amend multiple orders.
     *
     * @param string $orders An array of orders. (optional)
     * @return \Swagger\Client\Model\Order[]
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderAmendBulk($orders = null)
    {
        list($response) = $this->orderAmendBulkWithHttpInfo($orders);
        return $response;
    }

    /**
     * Operation orderAmendBulkWithHttpInfo
     *
     * Amend multiple orders.
     *
     * @param string $orders An array of orders. (optional)
     * @return Array of \Swagger\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderAmendBulkWithHttpInfo($orders = null)
    {
        // parse inputs
        $resourcePath = "/order/bulk";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($orders !== null) {
            $formParams['orders'] = $this->apiClient->getSerializer()->toFormValue($orders);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order[]',
                '/order/bulk'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order[]', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderCancel
     *
     * Cancel order(s). Send multiple order IDs to cancel in bulk.
     *
     * @param string $order_id Order ID(s). (optional)
     * @param string $cl_ord_id Client Order ID(s). See POST /order. (optional)
     * @param string $text Optional cancellation annotation. e.g. &#39;Spread Exceeded&#39;. (optional)
     * @return \Swagger\Client\Model\Order[]
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderCancel($order_id = null, $cl_ord_id = null, $text = null)
    {
        list($response) = $this->orderCancelWithHttpInfo($order_id, $cl_ord_id, $text);
        return $response;
    }

    /**
     * Operation orderCancelWithHttpInfo
     *
     * Cancel order(s). Send multiple order IDs to cancel in bulk.
     *
     * @param string $order_id Order ID(s). (optional)
     * @param string $cl_ord_id Client Order ID(s). See POST /order. (optional)
     * @param string $text Optional cancellation annotation. e.g. &#39;Spread Exceeded&#39;. (optional)
     * @return Array of \Swagger\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderCancelWithHttpInfo($order_id = null, $cl_ord_id = null, $text = null)
    {
        // parse inputs
        $resourcePath = "/order";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($order_id !== null) {
            $formParams['orderID'] = $this->apiClient->getSerializer()->toFormValue($order_id);
        }
        // form params
        if ($cl_ord_id !== null) {
            $formParams['clOrdID'] = $this->apiClient->getSerializer()->toFormValue($cl_ord_id);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = $this->apiClient->getSerializer()->toFormValue($text);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order[]',
                '/order'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order[]', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderCancelAll
     *
     * Cancels all of your orders.
     *
     * @param string $symbol Optional symbol. If provided, only cancels orders for that symbol. (optional)
     * @param string $filter Optional filter for cancellation. Use to only cancel some orders, e.g. &#x60;{\&quot;side\&quot;: \&quot;Buy\&quot;}&#x60;. (optional)
     * @param string $text Optional cancellation annotation. e.g. &#39;Spread Exceeded&#39; (optional)
     * @return object
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderCancelAll($symbol = null, $filter = null, $text = null)
    {
        list($response) = $this->orderCancelAllWithHttpInfo($symbol, $filter, $text);
        return $response;
    }

    /**
     * Operation orderCancelAllWithHttpInfo
     *
     * Cancels all of your orders.
     *
     * @param string $symbol Optional symbol. If provided, only cancels orders for that symbol. (optional)
     * @param string $filter Optional filter for cancellation. Use to only cancel some orders, e.g. &#x60;{\&quot;side\&quot;: \&quot;Buy\&quot;}&#x60;. (optional)
     * @param string $text Optional cancellation annotation. e.g. &#39;Spread Exceeded&#39; (optional)
     * @return Array of object, HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderCancelAllWithHttpInfo($symbol = null, $filter = null, $text = null)
    {
        // parse inputs
        $resourcePath = "/order/all";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($symbol !== null) {
            $formParams['symbol'] = $this->apiClient->getSerializer()->toFormValue($symbol);
        }
        // form params
        if ($filter !== null) {
            $formParams['filter'] = $this->apiClient->getSerializer()->toFormValue($filter);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = $this->apiClient->getSerializer()->toFormValue($text);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'object',
                '/order/all'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, 'object', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'object', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderCancelAllAfter
     *
     * Automatically cancel all your orders after a specified timeout.
     *
     * @param double $timeout Timeout in ms. Set to 0 to cancel this timer. (required)
     * @return object
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderCancelAllAfter($timeout)
    {
        list($response) = $this->orderCancelAllAfterWithHttpInfo($timeout);
        return $response;
    }

    /**
     * Operation orderCancelAllAfterWithHttpInfo
     *
     * Automatically cancel all your orders after a specified timeout.
     *
     * @param double $timeout Timeout in ms. Set to 0 to cancel this timer. (required)
     * @return Array of object, HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderCancelAllAfterWithHttpInfo($timeout)
    {
        // verify the required parameter 'timeout' is set
        if ($timeout === null) {
            throw new \InvalidArgumentException('Missing the required parameter $timeout when calling orderCancelAllAfter');
        }
        // parse inputs
        $resourcePath = "/order/cancelAllAfter";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($timeout !== null) {
            $formParams['timeout'] = $this->apiClient->getSerializer()->toFormValue($timeout);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'object',
                '/order/cancelAllAfter'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, 'object', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'object', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderClosePosition
     *
     * Close a position. [Deprecated, use POST /order with execInst: 'Close']
     *
     * @param string $symbol Symbol of position to close. (required)
     * @param double $price Optional limit price. (optional)
     * @return \Swagger\Client\Model\Order
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderClosePosition($symbol, $price = null)
    {
        list($response) = $this->orderClosePositionWithHttpInfo($symbol, $price);
        return $response;
    }

    /**
     * Operation orderClosePositionWithHttpInfo
     *
     * Close a position. [Deprecated, use POST /order with execInst: 'Close']
     *
     * @param string $symbol Symbol of position to close. (required)
     * @param double $price Optional limit price. (optional)
     * @return Array of \Swagger\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderClosePositionWithHttpInfo($symbol, $price = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null) {
            throw new \InvalidArgumentException('Missing the required parameter $symbol when calling orderClosePosition');
        }
        // parse inputs
        $resourcePath = "/order/closePosition";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($symbol !== null) {
            $formParams['symbol'] = $this->apiClient->getSerializer()->toFormValue($symbol);
        }
        // form params
        if ($price !== null) {
            $formParams['price'] = $this->apiClient->getSerializer()->toFormValue($price);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order',
                '/order/closePosition'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderGetOrders
     *
     * Get your orders.
     *
     * @param string $symbol Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. &#x60;XBU:monthly&#x60;. Timeframes are &#x60;daily&#x60;, &#x60;weekly&#x60;, &#x60;monthly&#x60;, &#x60;quarterly&#x60;, and &#x60;biquarterly&#x60;. (optional)
     * @param string $filter Generic table filter. Send JSON key/value pairs, such as &#x60;{\&quot;key\&quot;: \&quot;value\&quot;}&#x60;. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#timestamp-filters) for more details. (optional)
     * @param string $columns Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. (optional)
     * @param float $count Number of results to fetch. (optional, default to 100)
     * @param float $start Starting point for results. (optional, default to 0)
     * @param bool $reverse If true, will sort results newest first. (optional, default to false)
     * @param \DateTime $start_time Starting date filter for results. (optional)
     * @param \DateTime $end_time Ending date filter for results. (optional)
     * @return \Swagger\Client\Model\Order[]
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderGetOrders($symbol = null, $filter = null, $columns = null, $count = null, $start = null, $reverse = null, $start_time = null, $end_time = null)
    {
        list($response) = $this->orderGetOrdersWithHttpInfo($symbol, $filter, $columns, $count, $start, $reverse, $start_time, $end_time);
        return $response;
    }

    /**
     * Operation orderGetOrdersWithHttpInfo
     *
     * Get your orders.
     *
     * @param string $symbol Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. &#x60;XBU:monthly&#x60;. Timeframes are &#x60;daily&#x60;, &#x60;weekly&#x60;, &#x60;monthly&#x60;, &#x60;quarterly&#x60;, and &#x60;biquarterly&#x60;. (optional)
     * @param string $filter Generic table filter. Send JSON key/value pairs, such as &#x60;{\&quot;key\&quot;: \&quot;value\&quot;}&#x60;. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#timestamp-filters) for more details. (optional)
     * @param string $columns Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. (optional)
     * @param float $count Number of results to fetch. (optional, default to 100)
     * @param float $start Starting point for results. (optional, default to 0)
     * @param bool $reverse If true, will sort results newest first. (optional, default to false)
     * @param \DateTime $start_time Starting date filter for results. (optional)
     * @param \DateTime $end_time Ending date filter for results. (optional)
     * @return Array of \Swagger\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderGetOrdersWithHttpInfo($symbol = null, $filter = null, $columns = null, $count = null, $start = null, $reverse = null, $start_time = null, $end_time = null)
    {
        // parse inputs
        $resourcePath = "/order";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // query params
        if ($symbol !== null) {
            $queryParams['symbol'] = $this->apiClient->getSerializer()->toQueryValue($symbol);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns'] = $this->apiClient->getSerializer()->toQueryValue($columns);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = $this->apiClient->getSerializer()->toQueryValue($count);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = $this->apiClient->getSerializer()->toQueryValue($start);
        }
        // query params
        if ($reverse !== null) {
            $queryParams['reverse'] = $this->apiClient->getSerializer()->toQueryValue($reverse);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order[]',
                '/order'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order[]', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderNew
     *
     * Create a new order.
     *
     * @param string $symbol Instrument symbol. e.g. &#39;XBT24H&#39;. (required)
     * @param string $side Order side. Valid options: Buy, Sell. Defaults to &#39;Buy&#39; unless &#x60;orderQty&#x60; or &#x60;simpleOrderQty&#x60; is negative. (optional)
     * @param double $simple_order_qty Order quantity in units of the underlying instrument (i.e. Bitcoin). (optional)
     * @param float $quantity Deprecated: use &#x60;orderQty&#x60;. (optional)
     * @param float $order_qty Order quantity in units of the instrument (i.e. contracts). (optional)
     * @param double $price Optional limit price for &#39;Limit&#39;, &#39;StopLimit&#39;, and &#39;LimitIfTouched&#39; orders. (optional)
     * @param float $display_qty Optional quantity to display in the book. Use 0 for a hidden order. (optional)
     * @param double $stop_price Deprecated: use &#x60;stopPx&#x60;. (optional)
     * @param double $stop_px Optional trigger price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. Use &#x60;execInst&#x60; of &#39;MarkPrice&#39; or &#39;LastPrice&#39; to define the current price used for triggering. (optional)
     * @param string $cl_ord_id Optional Client Order ID. This clOrdID will come back on the order and any related executions. (optional)
     * @param string $cl_ord_link_id Optional Client Order Link ID for contingent orders. (optional)
     * @param double $peg_offset_value Optional trailing offset from the current price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for &#39;Pegged&#39; orders. (optional)
     * @param string $peg_price_type Optional peg price type. Valid options: LastPeg, MidPricePeg, MarketPeg, PrimaryPeg, TrailingStopPeg, TrailingStopPeg. (optional)
     * @param string $type Deprecated: use &#x60;ordType&#x60;. (optional)
     * @param string $ord_type Order type. Valid options: Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged. Defaults to &#39;Limit&#39; when &#x60;price&#x60; is specified. Defaults to &#39;Stop&#39; when &#x60;stopPx&#x60; is specified. Defaults to &#39;StopLimit&#39; when &#x60;price&#x60; and &#x60;stopPx&#x60; are specified. (optional, default to Limit)
     * @param string $time_in_force Time in force. Valid options: Day, GoodTillCancel, ImmediateOrCancel, FillOrKill. Defaults to &#39;GoodTillCancel&#39; for &#39;Limit&#39;, &#39;StopLimit&#39;, &#39;LimitIfTouched&#39;, and &#39;MarketWithLeftOverAsLimit&#39; orders. (optional)
     * @param string $exec_inst Optional execution instructions. Valid options: ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice, LastPrice, Close, ReduceOnly, Fixed. &#39;AllOrNone&#39; instruction requires &#x60;displayQty&#x60; to be 0. &#39;MarkPrice&#39; or &#39;LastPrice&#39; instruction valid for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders. (optional)
     * @param string $contingency_type Optional contingency type for use with &#x60;clOrdLinkID&#x60;. Valid options: OneCancelsTheOther, OneTriggersTheOther, OneUpdatesTheOtherAbsolute, OneUpdatesTheOtherProportional. (optional)
     * @param string $text Optional order annotation. e.g. &#39;Take profit&#39;. (optional)
     * @return \Swagger\Client\Model\Order
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderNew($symbol, $side = null, $simple_order_qty = null, $quantity = null, $order_qty = null, $price = null, $display_qty = null, $stop_price = null, $stop_px = null, $cl_ord_id = null, $cl_ord_link_id = null, $peg_offset_value = null, $peg_price_type = null, $type = null, $ord_type = null, $time_in_force = null, $exec_inst = null, $contingency_type = null, $text = null)
    {
        list($response) = $this->orderNewWithHttpInfo($symbol, $side, $simple_order_qty, $quantity, $order_qty, $price, $display_qty, $stop_price, $stop_px, $cl_ord_id, $cl_ord_link_id, $peg_offset_value, $peg_price_type, $type, $ord_type, $time_in_force, $exec_inst, $contingency_type, $text);
        return $response;
    }

    /**
     * Operation orderNewWithHttpInfo
     *
     * Create a new order.
     *
     * @param string $symbol Instrument symbol. e.g. &#39;XBT24H&#39;. (required)
     * @param string $side Order side. Valid options: Buy, Sell. Defaults to &#39;Buy&#39; unless &#x60;orderQty&#x60; or &#x60;simpleOrderQty&#x60; is negative. (optional)
     * @param double $simple_order_qty Order quantity in units of the underlying instrument (i.e. Bitcoin). (optional)
     * @param float $quantity Deprecated: use &#x60;orderQty&#x60;. (optional)
     * @param float $order_qty Order quantity in units of the instrument (i.e. contracts). (optional)
     * @param double $price Optional limit price for &#39;Limit&#39;, &#39;StopLimit&#39;, and &#39;LimitIfTouched&#39; orders. (optional)
     * @param float $display_qty Optional quantity to display in the book. Use 0 for a hidden order. (optional)
     * @param double $stop_price Deprecated: use &#x60;stopPx&#x60;. (optional)
     * @param double $stop_px Optional trigger price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. Use &#x60;execInst&#x60; of &#39;MarkPrice&#39; or &#39;LastPrice&#39; to define the current price used for triggering. (optional)
     * @param string $cl_ord_id Optional Client Order ID. This clOrdID will come back on the order and any related executions. (optional)
     * @param string $cl_ord_link_id Optional Client Order Link ID for contingent orders. (optional)
     * @param double $peg_offset_value Optional trailing offset from the current price for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for &#39;Pegged&#39; orders. (optional)
     * @param string $peg_price_type Optional peg price type. Valid options: LastPeg, MidPricePeg, MarketPeg, PrimaryPeg, TrailingStopPeg, TrailingStopPeg. (optional)
     * @param string $type Deprecated: use &#x60;ordType&#x60;. (optional)
     * @param string $ord_type Order type. Valid options: Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged. Defaults to &#39;Limit&#39; when &#x60;price&#x60; is specified. Defaults to &#39;Stop&#39; when &#x60;stopPx&#x60; is specified. Defaults to &#39;StopLimit&#39; when &#x60;price&#x60; and &#x60;stopPx&#x60; are specified. (optional, default to Limit)
     * @param string $time_in_force Time in force. Valid options: Day, GoodTillCancel, ImmediateOrCancel, FillOrKill. Defaults to &#39;GoodTillCancel&#39; for &#39;Limit&#39;, &#39;StopLimit&#39;, &#39;LimitIfTouched&#39;, and &#39;MarketWithLeftOverAsLimit&#39; orders. (optional)
     * @param string $exec_inst Optional execution instructions. Valid options: ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice, LastPrice, Close, ReduceOnly, Fixed. &#39;AllOrNone&#39; instruction requires &#x60;displayQty&#x60; to be 0. &#39;MarkPrice&#39; or &#39;LastPrice&#39; instruction valid for &#39;Stop&#39;, &#39;StopLimit&#39;, &#39;MarketIfTouched&#39;, and &#39;LimitIfTouched&#39; orders. (optional)
     * @param string $contingency_type Optional contingency type for use with &#x60;clOrdLinkID&#x60;. Valid options: OneCancelsTheOther, OneTriggersTheOther, OneUpdatesTheOtherAbsolute, OneUpdatesTheOtherProportional. (optional)
     * @param string $text Optional order annotation. e.g. &#39;Take profit&#39;. (optional)
     * @return Array of \Swagger\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderNewWithHttpInfo($symbol, $side = null, $simple_order_qty = null, $quantity = null, $order_qty = null, $price = null, $display_qty = null, $stop_price = null, $stop_px = null, $cl_ord_id = null, $cl_ord_link_id = null, $peg_offset_value = null, $peg_price_type = null, $type = null, $ord_type = null, $time_in_force = null, $exec_inst = null, $contingency_type = null, $text = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null) {
            throw new \InvalidArgumentException('Missing the required parameter $symbol when calling orderNew');
        }
        // parse inputs
        $resourcePath = "/order";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($symbol !== null) {
            $formParams['symbol'] = $this->apiClient->getSerializer()->toFormValue($symbol);
        }
        // form params
        if ($side !== null) {
            $formParams['side'] = $this->apiClient->getSerializer()->toFormValue($side);
        }
        // form params
        if ($simple_order_qty !== null) {
            $formParams['simpleOrderQty'] = $this->apiClient->getSerializer()->toFormValue($simple_order_qty);
        }
        // form params
        if ($quantity !== null) {
            $formParams['quantity'] = $this->apiClient->getSerializer()->toFormValue($quantity);
        }
        // form params
        if ($order_qty !== null) {
            $formParams['orderQty'] = $this->apiClient->getSerializer()->toFormValue($order_qty);
        }
        // form params
        if ($price !== null) {
            $formParams['price'] = $this->apiClient->getSerializer()->toFormValue($price);
        }
        // form params
        if ($display_qty !== null) {
            $formParams['displayQty'] = $this->apiClient->getSerializer()->toFormValue($display_qty);
        }
        // form params
        if ($stop_price !== null) {
            $formParams['stopPrice'] = $this->apiClient->getSerializer()->toFormValue($stop_price);
        }
        // form params
        if ($stop_px !== null) {
            $formParams['stopPx'] = $this->apiClient->getSerializer()->toFormValue($stop_px);
        }
        // form params
        if ($cl_ord_id !== null) {
            $formParams['clOrdID'] = $this->apiClient->getSerializer()->toFormValue($cl_ord_id);
        }
        // form params
        if ($cl_ord_link_id !== null) {
            $formParams['clOrdLinkID'] = $this->apiClient->getSerializer()->toFormValue($cl_ord_link_id);
        }
        // form params
        if ($peg_offset_value !== null) {
            $formParams['pegOffsetValue'] = $this->apiClient->getSerializer()->toFormValue($peg_offset_value);
        }
        // form params
        if ($peg_price_type !== null) {
            $formParams['pegPriceType'] = $this->apiClient->getSerializer()->toFormValue($peg_price_type);
        }
        // form params
        if ($type !== null) {
            $formParams['type'] = $this->apiClient->getSerializer()->toFormValue($type);
        }
        // form params
        if ($ord_type !== null) {
            $formParams['ordType'] = $this->apiClient->getSerializer()->toFormValue($ord_type);
        }
        // form params
        if ($time_in_force !== null) {
            $formParams['timeInForce'] = $this->apiClient->getSerializer()->toFormValue($time_in_force);
        }
        // form params
        if ($exec_inst !== null) {
            $formParams['execInst'] = $this->apiClient->getSerializer()->toFormValue($exec_inst);
        }
        // form params
        if ($contingency_type !== null) {
            $formParams['contingencyType'] = $this->apiClient->getSerializer()->toFormValue($contingency_type);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = $this->apiClient->getSerializer()->toFormValue($text);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order',
                '/order'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation orderNewBulk
     *
     * Create multiple new orders.
     *
     * @param string $orders An array of orders. (optional)
     * @return \Swagger\Client\Model\Order[]
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderNewBulk($orders = null)
    {
        list($response) = $this->orderNewBulkWithHttpInfo($orders);
        return $response;
    }

    /**
     * Operation orderNewBulkWithHttpInfo
     *
     * Create multiple new orders.
     *
     * @param string $orders An array of orders. (optional)
     * @return Array of \Swagger\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     * @throws \Swagger\Client\ApiException on non-2xx response
     */
    public function orderNewBulkWithHttpInfo($orders = null)
    {
        // parse inputs
        $resourcePath = "/order/bulk";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/json', 'application/xml', 'text/xml', 'application/javascript', 'text/javascript'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/json','application/x-www-form-urlencoded'));

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($orders !== null) {
            $formParams['orders'] = $this->apiClient->getSerializer()->toFormValue($orders);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Swagger\Client\Model\Order[]',
                '/order/bulk'
            );

            return array($this->apiClient->getSerializer()->deserialize($response, '\Swagger\Client\Model\Order[]', $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Order[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Swagger\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

}
